import { WebClient } from '@slack/web-api';

interface SlackNotification {
  channel?: string;
  text: string;
  blocks?: any[];
  username?: string;
  icon_emoji?: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  category: 'wellness' | 'achievement' | 'alert' | 'esg' | 'certificate' | 'message';
}

interface WebhookPayload {
  channel?: string;
  text: string;
  username?: string;
  icon_emoji?: string;
  blocks?: any[];
}

class SlackNotificationService {
  private webhookUrl: string | null;
  private botToken: string | null;
  private slackClient: WebClient | null;

  constructor() {
    this.webhookUrl = process.env.SLACK_WEBHOOK_URL || null;
    this.botToken = process.env.SLACK_BOT_TOKEN || null;
    this.slackClient = this.botToken ? new WebClient(this.botToken) : null;
  }

  private async sendWebhook(payload: WebhookPayload): Promise<void> {
    if (!this.webhookUrl) {
      console.log('Slack webhook not configured, skipping notification:', payload.text);
      return;
    }

    try {
      const response = await fetch(this.webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Webhook failed: ${response.status} ${response.statusText}`);
      }

      console.log('‚úÖ Slack notification sent:', payload.text);
    } catch (error) {
      console.error('‚ùå Failed to send Slack notification:', error);
    }
  }

  private getPriorityEmoji(priority: string): string {
    switch (priority) {
      case 'urgent': return 'üö®';
      case 'high': return '‚ö†Ô∏è';
      case 'medium': return 'üì¢';
      case 'low': return 'üí°';
      default: return 'üìù';
    }
  }

  private getCategoryEmoji(category: string): string {
    switch (category) {
      case 'wellness': return 'üåü';
      case 'achievement': return 'üèÜ';
      case 'alert': return '‚ö°';
      case 'esg': return 'üìä';
      case 'certificate': return 'üéì';
      case 'message': return 'üíå';
      default: return 'üìã';
    }
  }

  async sendNotification(notification: SlackNotification): Promise<void> {
    const priorityEmoji = this.getPriorityEmoji(notification.priority);
    const categoryEmoji = this.getCategoryEmoji(notification.category);
    
    const payload: WebhookPayload = {
      channel: notification.channel,
      text: `${priorityEmoji} ${categoryEmoji} ${notification.text}`,
      username: notification.username || 'EchoDeed‚Ñ¢ Wellness Platform',
      icon_emoji: notification.icon_emoji || ':heart:',
      blocks: notification.blocks,
    };

    await this.sendWebhook(payload);
  }

  // AI Prediction Engine Notifications
  async sendWellnessAlert(prediction: any): Promise<void> {
    const riskLevel = prediction.riskLevel || 'medium';
    const department = prediction.department || 'team';
    const confidence = Math.round((prediction.confidence || 0.85) * 100);
    
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üß† AI Wellness Alert: ${riskLevel.toUpperCase()} Risk Detected`,
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Department:* ${department}`
          },
          {
            type: 'mrkdwn',
            text: `*Risk Level:* ${riskLevel.charAt(0).toUpperCase() + riskLevel.slice(1)}`
          },
          {
            type: 'mrkdwn',
            text: `*Confidence:* ${confidence}%`
          },
          {
            type: 'mrkdwn',
            text: `*Prediction:* ${prediction.prediction || 'Team wellness support needed'}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Recommended Actions:*\n${prediction.recommendations?.slice(0, 3).map((rec: string) => `‚Ä¢ ${rec}`).join('\n') || '‚Ä¢ Schedule team check-in\n‚Ä¢ Provide wellness resources\n‚Ä¢ Monitor team morale'}`
        }
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `ü§ñ Generated by EchoDeed‚Ñ¢ AI Prediction Engine | Impact: ${prediction.estimatedImpact || 'High'}`
          }
        ]
      }
    ];

    await this.sendNotification({
      text: `AI detected ${riskLevel} wellness risk in ${department} with ${confidence}% confidence. Immediate intervention recommended.`,
      blocks,
      priority: riskLevel === 'high' ? 'urgent' : 'high',
      category: 'alert',
    });
  }

  // Global Wellness Heatmap Notifications
  async sendHeatmapAlert(data: any): Promise<void> {
    const criticalDepartments = data.departments?.filter((d: any) => d.riskLevel === 'high').length || 0;
    const overallScore = data.overallWellnessScore || 75;

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üó∫Ô∏è Global Wellness Heatmap Update',
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Overall Wellness Score:* ${overallScore}/100`
          },
          {
            type: 'mrkdwn',
            text: `*Critical Departments:* ${criticalDepartments}`
          },
          {
            type: 'mrkdwn',
            text: `*Total Responses:* ${data.totalResponses || 156} employees`
          },
          {
            type: 'mrkdwn',
            text: `*Last Updated:* ${new Date().toLocaleTimeString()}`
          }
        ]
      }
    ];

    if (criticalDepartments > 0) {
      await this.sendNotification({
        text: `üö® Wellness Alert: ${criticalDepartments} departments showing critical wellness levels. Overall score: ${overallScore}/100`,
        blocks,
        priority: 'urgent',
        category: 'alert',
      });
    }
  }

  // Smart Kindness Matching Notifications
  async sendMatchingSuccess(match: any): Promise<void> {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üéØ Perfect Kindness Match Found!',
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Opportunity:* ${match.title || 'Community Support'}`
          },
          {
            type: 'mrkdwn',
            text: `*Match Accuracy:* ${match.accuracy || 94}%`
          },
          {
            type: 'mrkdwn',
            text: `*Participants:* ${match.participants || 12} employees`
          },
          {
            type: 'mrkdwn',
            text: `*Impact Score:* ${match.impactScore || 8.7}/10`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Description:* ${match.description || 'A perfectly matched opportunity to make a positive impact in your community.'}`
        }
      }
    ];

    await this.sendNotification({
      text: `üéØ AI found perfect kindness match: "${match.title}" with ${match.accuracy}% accuracy for ${match.participants} employees!`,
      blocks,
      priority: 'medium',
      category: 'achievement',
    });
  }

  // ESG Impact Reporting Notifications
  async sendESGReport(report: any): Promise<void> {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üìä ${report.title || 'ESG Impact Report'} Ready`,
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Overall Score:* ${report.totalScore || 87.5}/100`
          },
          {
            type: 'mrkdwn',
            text: `*Industry Ranking:* #${report.industryRanking || 12}`
          },
          {
            type: 'mrkdwn',
            text: `*Period:* ${report.period || 'Q4 2024'}`
          },
          {
            type: 'mrkdwn',
            text: `*Status:* ${report.status || 'Final'}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Key Achievements:*\n${report.achievements?.slice(0, 3).map((achievement: string) => `‚úÖ ${achievement}`).join('\n') || '‚úÖ Exceeded carbon offset targets\n‚úÖ 94% wellness participation\n‚úÖ B-Corp certification received'}`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Download Report üì•',
            },
            url: report.downloadUrl || '#',
            style: 'primary'
          }
        ]
      }
    ];

    await this.sendNotification({
      text: `üìä ESG Report "${report.title}" complete! Score: ${report.totalScore}/100, Industry Rank: #${report.industryRanking}`,
      blocks,
      priority: 'high',
      category: 'esg',
    });
  }

  // Blockchain Certificate Notifications
  async sendCertificateAchievement(certificate: any): Promise<void> {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üèÜ ${certificate.level || 'Gold'} Certificate Earned!`,
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Achievement:* ${certificate.title || 'Kindness Pioneer'}`
          },
          {
            type: 'mrkdwn',
            text: `*Level:* ${certificate.level || 'Gold'}`
          },
          {
            type: 'mrkdwn',
            text: `*Rarity:* ${certificate.rarity || 12.3}% of users`
          },
          {
            type: 'mrkdwn',
            text: `*Blockchain:* ${certificate.blockchainNetwork || 'EchoDeed Chain'}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Impact Metrics:*\n‚Ä¢ üë• ${certificate.impactMetrics?.peopleHelped || 134} people helped\n‚Ä¢ ‚è∞ ${certificate.impactMetrics?.hoursContributed || 89} hours contributed\n‚Ä¢ üåç ${certificate.impactMetrics?.co2Offset || 245}kg CO2 offset`
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Certificate üéì',
            },
            url: certificate.certificateUrl || '#',
            style: 'primary'
          },
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Verify Blockchain üîó',
            },
            url: certificate.verificationUrl || '#'
          }
        ]
      }
    ];

    await this.sendNotification({
      text: `üèÜ Congratulations! ${certificate.level} certificate "${certificate.title}" earned and blockchain-verified! Only ${certificate.rarity}% of users achieve this.`,
      blocks,
      priority: 'high',
      category: 'certificate',
    });
  }

  // Time-Locked Message Notifications
  async sendMessageDelivered(message: any): Promise<void> {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚è∞ Time-Locked Wellness Message Delivered!',
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Subject:* ${message.subject || 'Weekly Motivation'}`
          },
          {
            type: 'mrkdwn',
            text: `*Recipients:* ${message.recipientCount || 1} people`
          },
          {
            type: 'mrkdwn',
            text: `*Category:* ${message.category || 'encouragement'}`
          },
          {
            type: 'mrkdwn',
            text: `*Scheduled:* ${message.scheduledDelay || '3 days ago'}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Message Preview:* "${message.content?.substring(0, 150) || 'Your positive impact makes a real difference...'}${message.content?.length > 150 ? '...' : ''}"`
        }
      }
    ];

    await this.sendNotification({
      text: `‚è∞ Time-locked message "${message.subject}" successfully delivered to ${message.recipientCount} recipients! Perfect timing achieved.`,
      blocks,
      priority: 'medium',
      category: 'message',
    });
  }

  // General Achievement Notifications
  async sendGeneralAchievement(data: any): Promise<void> {
    await this.sendNotification({
      text: `üéâ ${data.message || 'New achievement unlocked!'} - ${data.details || 'Great work on your wellness journey!'}`,
      priority: data.priority || 'medium',
      category: 'achievement',
    });
  }

  // System Health Notifications
  async sendSystemAlert(alert: any): Promise<void> {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚ö†Ô∏è EchoDeed‚Ñ¢ System Alert',
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Alert:* ${alert.message || 'System notification'}\n*Severity:* ${alert.severity || 'Medium'}\n*Time:* ${new Date().toLocaleTimeString()}`
        }
      }
    ];

    await this.sendNotification({
      text: `‚ö†Ô∏è System Alert: ${alert.message}`,
      blocks,
      priority: alert.severity === 'High' ? 'urgent' : 'high',
      category: 'alert',
    });
  }
}

export const slackNotifications = new SlackNotificationService();